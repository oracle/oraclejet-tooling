/**
  Copyright (c) 2015, 2023, Oracle and/or its affiliates.
  Licensed under The Universal Permissive License (UPL), Version 1.0
  as shown at https://oss.oracle.com/licenses/upl/

*/
const path = require('path');
const glob = require('glob');
const fs = require('fs-extra');
const ojetUtils = require('../util');
const injector = require('../indexHtmlInjector');
const config = require('../config');
const valid = require('../validations');
const constants = require('../constants');

const configPaths = ojetUtils.getConfiguredPaths();
const exchangeComponentsPath = path.resolve(configPaths.exchangeComponents);
const localComponentsPath = path.resolve(
  configPaths.src.common,
  configPaths.src.typescript,
  configPaths.components
);
const oracleJetPreactPath = 'node_modules/@oracle/oraclejet-preact/es';
const oracleJetDistPath = path.join(ojetUtils.getOraclejetPath(), 'dist');
const oracleJetDistCssPath = path.join(oracleJetDistPath, 'css');
const oracleJetDistJsLibsPath = path.join(oracleJetDistPath, 'js/libs');
// eslint-disable-next-line no-useless-escape
const htmlTokenPattern = /(<!--\s*|@@)(css|js|img|injector):([\w-\/]+)(\s*-->)?/g;
// eslint-disable-next-line no-useless-escape
const htmlEndInjectorTokenPattern = /(<!--\s*|@@)([\w\/]+)(\s*-->)/g;
// eslint-disable-next-line no-useless-escape
const htmlAppCssLinkTokenPattern = /<\w+\s*\w+[^abc]+css[^abc]app.css[^abc]+css[^abc]+>/g;

/**
 * ## isWebComponent
 *
 */
function isWebComponent(resourcePath) {
  let component;
  const normalizedResourcePath = path.normalize(resourcePath);
  if (normalizedResourcePath.startsWith(exchangeComponentsPath)) {
    component = path.relative(exchangeComponentsPath, normalizedResourcePath).split(path.sep)[0];
  } else if (normalizedResourcePath.startsWith(localComponentsPath)) {
    component = path.relative(localComponentsPath, normalizedResourcePath).split(path.sep)[0];
  }
  return component === undefined ? false : !!ojetUtils.getComponentsCache()[component];
}

/**
 * ## organizeTypeDefinitions
 *
 */
function organizeTypeDefinitions() {
  const tsFilesTypesFolder = path.resolve(configPaths.staging.stagingPath, 'types');
  ojetUtils.ensureDir(tsFilesTypesFolder);
  if (fs.existsSync(tsFilesTypesFolder)) {
    // get all *.d.ts files not in types or min (release build)
    glob.sync(
      path.join(configPaths.src.common, '**/*.d.ts'), {
        ignore: ['**/types/**', '**/min/**']
      }
    ).forEach((filePath) => {
      // loop through found *.d.ts files
      if (ojetUtils.fsExistsSync(path.join(
        tsFilesTypesFolder,
        path.relative(configPaths.src.common, filePath)
      ))) {
        // already exists in types folder, delete
        fs.removeSync(filePath);
      } else if (path.basename(filePath).startsWith('exports_')) {
        // special build time resource generated by custom-tsc, delete
        fs.removeSync(filePath);
      } else {
        // not in types folder, move into
        fs.moveSync(filePath, path.join(
          tsFilesTypesFolder,
          path.relative(configPaths.src.common, filePath)
        ));
      }
    });
  }
}

/**
 * ## getEntryFilePath
 *
 * @returns {string} path to the root file
 */
function getEntryFilePath() {
  if (ojetUtils.isVDOMApplication()) {
    return path.resolve(configPaths.src.common, 'index.ts');
  }
  if (ojetUtils.isTypescriptApplication()) {
    return path.resolve(configPaths.src.common, 'ts', 'root.ts');
  }
  return path.resolve(configPaths.src.common, 'js', 'root.js');
}

/**
 * ## getRootPath
 *
 * @returns {string} path to root folder
 */
function getRootPath() {
  if (ojetUtils.isVDOMApplication()) {
    return path.resolve(configPaths.staging.web,
      configPaths.src.javascript);
  }
  if (ojetUtils.isTypescriptApplication()) {
    return path.resolve(configPaths.src.common,
      configPaths.src.typescript);
  }
  return path.resolve(configPaths.src.common,
    configPaths.src.javascript);
}

/**
 * ## getThemeStyleArray
 *
 * @param {Object} context
 * @returns {Array} array with paths to theme files
 */
function getThemeStyleArray(context) {
  let themeStyleArray;
  const css = config('paths').src.styles;
  const theme = context.opts.theme;
  const buildType = context.buildType;
  const baseTheme = theme.basetheme || theme.name;
  const linkBase = injector.getStyleLinkBase(css, theme, buildType);
  if (linkBase.default && (baseTheme === 'redwood' || baseTheme === 'stable')) {
    themeStyleArray = [linkBase.default, linkBase.preact];
  } else if (baseTheme === 'redwood' || baseTheme === 'stable') {
    themeStyleArray = [linkBase.created, linkBase.preact];
  }

  return themeStyleArray;
}

/**
 * ## getCustomThemeEntryObj
 *
 * @returns {Object}
 */
function getCustomThemeEntryObj() {
  const customThemeEntryObj = {};
  const context = config.get('_context');
  const css = config('paths').src.styles;
  const theme = context.opts.theme;
  const buildType = context.buildType;
  const linkBase = injector.getStyleLinkBase(css, theme, buildType);
  // Path to custom theme in web. Using this path as the key of the
  // entry object, then webpack will generate this path in web and
  // emit the processed css files into it:
  const pathToCustomThemeInWeb = path.join(
    theme.name,
    theme.version,
    theme.platform,
    theme.name
  );
  // Path to custom theme in src. This will be our entry file for the
  // custom theme:
  const pathToCustomThemeInSrc = path.resolve(
    config('paths').src.common,
    'themes',
    theme.name,
    theme.platform,
    `${theme.name}.scss`
  );

  if (linkBase.created && !(theme.name === 'redwood' || theme.name === 'stable')) {
    customThemeEntryObj[`${pathToCustomThemeInWeb}`] = [pathToCustomThemeInSrc];
  }

  return customThemeEntryObj;
}

/**
 * ## getEntryObject
 *
 * @returns {Object}
 */
function getEntryObject() {
  const customThemeEntryObj = getCustomThemeEntryObj();
  const applicationEntryFile = getEntryFilePath();
  return {
    ...customThemeEntryObj,
    main: applicationEntryFile
  };
}

/**
 * ## getStyleLinkTags
 *
 * @returns {string} concatenated style link tag strings
 */
function getStyleLinkTags() {
  let themeStyleLinkTags = '';
  const context = config.get('_context');

  // Generate style link tags for theme styles:
  const pathsToThemeStyles = getThemeStyleArray(context);
  const linkTag = '<link rel="stylesheet" type="text/css" href="%s">';
  pathsToThemeStyles.forEach((pathToThemeStyle) => {
    themeStyleLinkTags = themeStyleLinkTags.concat(linkTag.replace('%s', pathToThemeStyle).concat('\n'));
  });

  // Generate link tags for the general app style:
  let pathToAppStyle = '';
  if (context.buildType === 'release' && !ojetUtils.isVDOMApplication()) {
    pathToAppStyle = path.join(`${configPaths.src.styles}`, 'app-min.css');
  } else {
    pathToAppStyle = path.join(`${configPaths.src.styles}`, 'app.css');
  }
  const appStyleLinkTag = `<link rel="stylesheet" type="text/css" href="${pathToAppStyle}">`;

  // Finally, concatenate themeStyleLinkTags with appStyleLinkTag:
  const styleLinkTags = `${themeStyleLinkTags}\n${appStyleLinkTag}`;

  return styleLinkTags;
}

/**
 * ## copyRequiredAltaFilesToStaging
 *
 * @param {Object} context
 */
function copyRequiredAltaFilesToStaging(context) {
  // The required folders will be 'common' and the chosen platform (web, windows, etc).
  // We need the contents of these folders because we are redirecting some paths in the
  // generated css file (see webpack.common under the css-fix-url loader) to the resources
  // that are only found in the required folders.
  const requiredFolders = ['common', context.platform];
  requiredFolders.forEach((folder) => {
    const scrPath = path.resolve(configPaths.staging.themes, 'alta', folder);
    let destPath = path.resolve(configPaths.staging.web, configPaths.src.styles, 'alta');
    destPath = !context.opts[constants.OMIT_COMPONENT_VERSION_FLAG] ? path.join(destPath, `${ojetUtils.getJETVersion()}`, folder) : path.join(destPath, folder);
    if (fs.existsSync(scrPath)) {
      fs.copySync(scrPath, destPath, {
        dereference: true
      });
    }
  });
}

/**
 * ## createContext
 *
 * @param {Object} options
 * @param {String} platform
 */
function createContext({
  options,
  platform
}) {
  config.loadOraclejetConfig(platform);
  const validPlatform = valid.platform(platform);
  const validOptions = valid.buildOptions(options, validPlatform);
  const validBuildType = valid.buildType(validOptions);
  return {
    buildType: validBuildType,
    opts: validOptions,
    platform: validPlatform
  };
}

/**
 * ## getCopyPluginPatterns
 *
 * @param {Array} platform
 */
function getCopyPluginPatterns() {
  const context = config.get('_context');
  const theme = context.opts.theme;
  const baseTheme = theme.basetheme || theme.name;

  if (baseTheme === 'redwood' || baseTheme === 'stable') {
    return [{
      from: path.join(configPaths.src.common, configPaths.src.styles),
      to: path.join(configPaths.src.styles),
    },
    {
      from: path.join(oracleJetDistCssPath, baseTheme),
      // Treverse the folder and emit the oj- prefix in css files
      // starting with such or replace the '-min' with '.min' in minified
      // styles. We are doing so to abide by the naming convention.
      to: ({ absoluteFilename }) => {
        const stat = fs.lstatSync(absoluteFilename);
        let filename = path.basename(absoluteFilename);
        const pathToPlatformFolder = path.join(
          configPaths.src.styles,
          baseTheme,
          ojetUtils.getJETVersion(),
          theme.platform
        );
        if (stat.isFile() && filename.includes(`oj-${baseTheme}`)) {
          filename = filename.replace(`oj-${baseTheme}`, baseTheme);
          if (filename.includes(`${baseTheme}-min`)) {
            filename = filename.replace(`${baseTheme}-min`, `${baseTheme}.min`);
          }
          return path.join(pathToPlatformFolder, filename);
        }
        return pathToPlatformFolder;
      },
      noErrorOnMissing: true
    },
    {
      from: path.join(oracleJetPreactPath, `Theme-${baseTheme}`),
      to: path.join(configPaths.src.styles, `theme-${baseTheme}`, ojetUtils.getJETVersion(), theme.platform),
      noErrorOnMissing: true
    }
    ];
  }

  return [{
    from: path.join(configPaths.src.common, configPaths.src.styles),
    to: path.join(configPaths.src.styles),
  }];
}

module.exports = {
  isWebComponent,
  localComponentsPath,
  exchangeComponentsPath,
  oracleJetDistPath,
  oracleJetDistCssPath,
  oracleJetDistJsLibsPath,
  htmlTokenPattern,
  htmlEndInjectorTokenPattern,
  htmlAppCssLinkTokenPattern,
  getEntryFilePath,
  organizeTypeDefinitions,
  getRootPath,
  getThemeStyleArray,
  getStyleLinkTags,
  copyRequiredAltaFilesToStaging,
  createContext,
  getCopyPluginPatterns,
  getCustomThemeEntryObj,
  getEntryObject
};
