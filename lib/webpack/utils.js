/**
  Copyright (c) 2015, 2023, Oracle and/or its affiliates.
  Licensed under The Universal Permissive License (UPL), Version 1.0
  as shown at https://oss.oracle.com/licenses/upl/

*/
const path = require('path');
const glob = require('glob');
const fs = require('fs-extra');
const ojetUtils = require('../util');
const injector = require('../indexHtmlInjector');
const config = require('../config');
const valid = require('../validations');
const constants = require('../constants');

const configPaths = ojetUtils.getConfiguredPaths();
const exchangeComponentsPath = path.resolve(configPaths.exchangeComponents);
const localComponentsPath = path.resolve(
  configPaths.src.common,
  configPaths.src.typescript,
  configPaths.components
);
const oracleJetDistPath = path.join(ojetUtils.getOraclejetPath(), 'dist');
const oracleJetDistCssPath = path.join(oracleJetDistPath, 'css');
const oracleJetDistJsLibsPath = path.join(oracleJetDistPath, 'js/libs');
// eslint-disable-next-line no-useless-escape
const htmlTokenPattern = /(<!--\s*|@@)(css|js|img|injector):([\w-\/]+)(\s*-->)?/g;
// eslint-disable-next-line no-useless-escape
const htmlEndInjectorTokenPattern = /(<!--\s*|@@)([\w\/]+)(\s*-->)/g;
// eslint-disable-next-line no-useless-escape
const htmlAppCssLinkTokenPattern = /<\w+\s*\w+[^abc]+css[^abc]app.css[^abc]+css[^abc]+>/g;

/**
 * ## isWebComponent
 *
 */
function isWebComponent(resourcePath) {
  let component;
  const normalizedResourcePath = path.normalize(resourcePath);
  if (normalizedResourcePath.startsWith(exchangeComponentsPath)) {
    component = path.relative(exchangeComponentsPath, normalizedResourcePath).split(path.sep)[0];
  } else if (normalizedResourcePath.startsWith(localComponentsPath)) {
    component = path.relative(localComponentsPath, normalizedResourcePath).split(path.sep)[0];
  }
  return component === undefined ? false : !!ojetUtils.getComponentsCache()[component];
}

/**
 * ## organizeTypeDefinitions
 *
 */
function organizeTypeDefinitions() {
  const tsFilesTypesFolder = path.resolve(configPaths.staging.stagingPath, 'types');
  ojetUtils.ensureDir(tsFilesTypesFolder);
  if (fs.existsSync(tsFilesTypesFolder)) {
    // get all *.d.ts files not in types or min (release build)
    glob.sync(
      path.join(configPaths.src.common, '**/*.d.ts'), {
        ignore: ['**/types/**', '**/min/**']
      }
    ).forEach((filePath) => {
      // loop through found *.d.ts files
      if (ojetUtils.fsExistsSync(path.join(
        tsFilesTypesFolder,
        path.relative(configPaths.src.common, filePath)
      ))) {
        // already exists in types folder, delete
        fs.removeSync(filePath);
      } else if (path.basename(filePath).startsWith('exports_')) {
        // special build time resource generated by custom-tsc, delete
        fs.removeSync(filePath);
      } else {
        // not in types folder, move into
        fs.moveSync(filePath, path.join(
          tsFilesTypesFolder,
          path.relative(configPaths.src.common, filePath)
        ));
      }
    });
  }
}

/**
 * ## getEntryFilePath
 *
 * @returns {string} path to the root file
 */
function getEntryFilePath() {
  if (ojetUtils.isVDOMApplication()) {
    return path.resolve(configPaths.src.common, 'index.ts');
  }
  if (ojetUtils.isTypescriptApplication()) {
    return path.resolve(configPaths.src.common, 'ts', 'root.ts');
  }
  return path.resolve(configPaths.src.common, 'js', 'root.js');
}

/**
 * ## getRootPath
 *
 * @returns {string} path to root folder
 */
function getRootPath() {
  if (ojetUtils.isVDOMApplication()) {
    return path.resolve(configPaths.staging.web,
      configPaths.src.javascript);
  }
  if (ojetUtils.isTypescriptApplication()) {
    return path.resolve(configPaths.src.common,
      configPaths.src.typescript);
  }
  return path.resolve(configPaths.src.common,
    configPaths.src.javascript);
}

/**
 * ## getThemeStyleArray
 *
 * @param {Object} context
 * @returns {Array} array with paths to theme files
 */
function getThemeStyleArray(context) {
  let themeStyleArray;
  const css = config('paths').src.styles;
  const theme = context.opts.theme;
  const buildType = context.buildType;
  const linkBase = injector.getStyleLinkBase(css, theme, buildType);
  if (linkBase.default) {
    themeStyleArray = theme.name === 'redwood' ? [linkBase.default, linkBase.created, linkBase.preact] : [linkBase.default, linkBase.created];
    return themeStyleArray;
  }
  themeStyleArray = theme.name === 'redwood' ? [linkBase.created, linkBase.preact] : [linkBase.created];
  return themeStyleArray;
}

/**
 * ## injectCDNCssUrl
 *
 * @returns {string} path to the CDN css files or empty string
 */
function injectCDNCssUrl() {
  const context = config.get('_context');
  const themes = getThemeStyleArray(context);
  let themesToInject = '';
  const injectedLink = '<link rel="stylesheet" type="text/css" href="%s">';
  const regex = /oracle.com\/cdn\/jet/gm;
  themes.forEach((theme) => {
    if (regex.test(theme)) {
      themesToInject = themesToInject.concat(injectedLink.replace('%s', theme).concat('\n'));
    }
  });
  return themesToInject;
}

/**
 * ## getAppCssFilesPath
 *
 * @param {Object} context
 * @returns {string} path to the app css files
 */
function getAppCssFilesPath(context) {
  const buildType = context.buildType;
  const appCSSPath = path.resolve(configPaths.staging.web, `${configPaths.src.styles}`, 'app.css');
  const pathToAppCSS = buildType === 'release' && !ojetUtils.isVDOMApplication() ?
    appCSSPath.replace('app.css', 'app-min.css') : appCSSPath;
  return pathToAppCSS;
}

/**
 * ## copyRequiredAltaFilesToStaging
 *
 * @param {Object} context
 */
function copyRequiredAltaFilesToStaging(context) {
  // The required folders will be 'common' and the chosen platform (web, windows, etc).
  // We need the contents of these folders because we are redirecting some paths in the
  // generated css file (see webpack.common under the css-fix-url loader) to the resources
  // that are only found in the required folders.
  const requiredFolders = ['common', context.platform];
  requiredFolders.forEach((folder) => {
    const scrPath = path.resolve(configPaths.staging.themes, 'alta', folder);
    let destPath = path.resolve(configPaths.staging.web, configPaths.src.styles, 'alta');
    destPath = !context.opts[constants.OMIT_COMPONENT_VERSION_FLAG] ? path.join(destPath, `${ojetUtils.getJETVersion()}`, folder) : path.join(destPath, folder);
    if (fs.existsSync(scrPath)) {
      fs.copySync(scrPath, destPath, { dereference: true });
    }
  });
}

/**
 * ## createContext
 *
 * @param {Object} options
 * @param {String} platform
 */
function createContext({
  options,
  platform
}) {
  config.loadOraclejetConfig(platform);
  const validPlatform = valid.platform(platform);
  const validOptions = valid.buildOptions(options, validPlatform);
  const validBuildType = valid.buildType(validOptions);
  return {
    buildType: validBuildType,
    opts: validOptions,
    platform: validPlatform
  };
}

module.exports = {
  isWebComponent,
  localComponentsPath,
  exchangeComponentsPath,
  oracleJetDistPath,
  oracleJetDistCssPath,
  oracleJetDistJsLibsPath,
  htmlTokenPattern,
  htmlEndInjectorTokenPattern,
  htmlAppCssLinkTokenPattern,
  getEntryFilePath,
  organizeTypeDefinitions,
  getRootPath,
  getThemeStyleArray,
  getAppCssFilesPath,
  injectCDNCssUrl,
  copyRequiredAltaFilesToStaging,
  createContext
};
